name: Generate dynamic sitemap

on:
  push:
    branches:
      - main
      - master

permissions:
  contents: write

env:
  SITE_URL: "https://kramorant.github.io"   # Cambia si usas dominio personalizado
  BUILD_DIR: "dist"                         # Carpeta donde están los HTML generados; usa "." si no hay build
  SITEMAP_PATH: "sitemap.xml"
  ROBOTS_PATH: "robots.txt"
  CREATE_PR_INSTEAD_OF_PUSH: "false"       # "true" para abrir PR en vez de push directo

jobs:
  sitemap:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Optional: Run build (uncomment if you have a build step)
        if: false
        run: |
          # npm ci
          # npm run build
          echo "Build step disabled by default. Enable and edit this step if needed."

      - name: Ensure robots.txt exists (create if missing)
        id: ensure-robots
        run: |
          if [ -f "${{ env.ROBOTS_PATH }}" ]; then
            echo "robots.txt found."
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "robots.txt not found. Creating default robots.txt."
            cat > "${{ env.ROBOTS_PATH }}" <<EOF
# robots.txt generated by workflow
User-agent: *
Disallow:
Sitemap: ${{ env.SITE_URL }}/${{ env.SITEMAP_PATH }}
EOF
            git add "${{ env.ROBOTS_PATH }}"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate sitemap.xml from built HTML files
        id: gen-sitemap
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          const siteUrl = (process.env.SITE_URL || '').replace(/\/$/, '');
          const buildDir = process.env.BUILD_DIR || '.';
          const sitemapPath = process.env.SITEMAP_PATH || 'sitemap.xml';

          function walk(dir) {
            let results = [];
            if (!fs.existsSync(dir)) return results;
            const list = fs.readdirSync(dir);
            list.forEach(file => {
              const full = path.join(dir, file);
              const stat = fs.statSync(full);
              if (stat.isDirectory()) {
                results = results.concat(walk(full));
              } else {
                if (full.endsWith('.html')) results.push(full);
              }
            });
            return results;
          }

          const htmlFiles = walk(buildDir)
            .map(f => path.relative(process.cwd(), f))
            .filter(f => !f.startsWith('.git/'));

          function lastMod(file) {
            try {
              const out = execSync('git log -1 --format=%cI -- ' + JSON.stringify(file)).toString().trim();
              return out || new Date().toISOString();
            } catch (e) {
              try {
                const stat = fs.statSync(file);
                return stat.mtime.toISOString();
              } catch (e2) {
                return new Date().toISOString();
              }
            }
          }

          function computePriority(urlPath) {
            // Reglas simples por tipo de ruta; personaliza según tu sitio
            if (urlPath === '/' || urlPath === '/index.html') return '1.00';
            if (urlPath.startsWith('/projects') || urlPath.startsWith('/portfolio')) return '0.80';
            if (urlPath.startsWith('/blog') || urlPath.startsWith('/posts')) return '0.70';
            return '0.50';
          }

          function computeChangefreq(urlPath) {
            if (urlPath === '/' || urlPath.startsWith('/projects')) return 'weekly';
            if (urlPath.startsWith('/blog')) return 'daily';
            return 'monthly';
          }

          const urls = htmlFiles.map(f => {
            // Convertir ruta de archivo a ruta web
            let rel = f.replace(/\\/g, '/');
            // Si está en buildDir, quitar prefijo
            const prefix = (buildDir === '.' ? '' : buildDir.replace(/\/$/, '') + '/');
            if (rel.startsWith(prefix)) rel = rel.slice(prefix.length);
            // index.html -> /
            const locPath = (rel === 'index.html') ? '/' : '/' + rel;
            return {
              file: f,
              path: locPath,
              loc: siteUrl + (locPath === '/' ? '/' : locPath),
              lastmod: lastMod(f),
              priority: computePriority(locPath),
              changefreq: computeChangefreq(locPath)
            };
          });

          const xmlItems = urls.map(u => \`
  <url>
    <loc>\${u.loc}</loc>
    <lastmod>\${u.lastmod}</lastmod>
    <changefreq>\${u.changefreq}</changefreq>
    <priority>\${u.priority}</priority>
  </url>\`).join('\\n');

          const xml = '<?xml version="1.0" encoding="UTF-8"?>\\n' +
            '<urlset xmlns="https://www.sitemaps.org/schemas/sitemap/0.9">\\n' +
            xmlItems + '\\n</urlset>\\n';

          const prev = fs.existsSync(sitemapPath) ? fs.readFileSync(sitemapPath,'utf8') : null;
          if (prev !== xml) {
            fs.writeFileSync(sitemapPath, xml, 'utf8');
            console.log('Sitemap updated: ' + sitemapPath);
            process.exitCode = 0;
          } else {
            console.log('No changes to sitemap.');
            process.exitCode = 0;
          }
          NODE

      - name: Commit and push sitemap (or open PR)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "${{ env.SITEMAP_PATH }}" "${{ env.ROBOTS_PATH }}" || true
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          if [ "${{ env.CREATE_PR_INSTEAD_OF_PUSH }}" = "true" ]; then
            # Crear PR usando create-pull-request action
            git commit -m "chore: update sitemap and robots (generated by workflow)"
            git push origin HEAD:${{ github.ref_name }}
            echo "Changes pushed; creating pull request..."
            gh pr create --title "chore: update sitemap and robots (generated)" --body "Sitemap and robots updated by CI" --base ${{ github.ref_name }} || echo "gh CLI not available; PR creation skipped"
          else
            git commit -m "chore: update sitemap and robots (generated by workflow)"
            git push origin HEAD:${{ github.ref_name }}
            echo "Sitemap and robots committed and pushed."
          fi
